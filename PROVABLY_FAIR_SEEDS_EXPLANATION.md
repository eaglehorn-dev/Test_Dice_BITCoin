# üîê Provably Fair System: The 3 Seeds Explained

## Overview

The provably fair system uses **3 cryptographic seeds** to ensure complete transparency and fairness. This document explains each seed in detail.

---

## üìã The 3 Seeds

### 1. **Server Seed** (Secret - Hidden Until Revealed)
- **What it is**: A cryptographically secure random 64-character hexadecimal string
- **Generated by**: Server (using Python's `secrets.token_hex()`)
- **Example**: `a3f8b2c9d1e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0`
- **Visibility**: **HIDDEN** from user until after the bet is placed and rolled
- **Purpose**: Ensures the server cannot manipulate results after seeing the bet

**Code:**
```python
server_seed = secrets.token_hex(32)  # 64 hex characters (256 bits of entropy)
```

---

### 2. **Server Seed Hash** (Public - Shown Before Bet)
- **What it is**: SHA256 hash of the server seed
- **Generated by**: Server (hashing the server seed)
- **Example**: `5e8f3a2b1c9d4e7f6a5b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1`
- **Visibility**: **PUBLIC** - shown to user BEFORE placing bet
- **Purpose**: 
  - Proves the server committed to a specific seed before the bet
  - User can verify later that the revealed server seed matches this hash
  - Prevents server from changing the seed after seeing the bet outcome

**Code:**
```python
server_seed_hash = hashlib.sha256(server_seed.encode()).hexdigest()
```

**Security Property**: 
- One-way function: Cannot reverse hash to get original seed
- Collision-resistant: Different seeds produce different hashes
- User can verify: `SHA256(revealed_server_seed) == server_seed_hash`

---

### 3. **Client Seed** (Public - Known to User)
- **What it is**: User's Bitcoin address (or random hex if no address)
- **Generated by**: Server (using user's address or random generation)
- **Example**: `tb1qsru9k26ddv9x8y5z4m3n2p1q0w9e8r7t6y5u4i3o2p1a0s9d8f7g6h5j4k3`
- **Visibility**: **PUBLIC** - user knows their own address
- **Purpose**: 
  - Adds user-controlled randomness to the mix
  - Prevents server from pre-calculating all outcomes
  - User can verify calculations using their known address

**Code:**
```python
if user_address:
    client_seed = user_address  # Use Bitcoin address
else:
    client_seed = secrets.token_hex(32)  # Random if no address
```

---

## üîÑ How They Work Together

### **Step-by-Step Process:**

#### **Phase 1: Before Bet (Commitment)**
1. Server generates `server_seed` (secret)
2. Server calculates `server_seed_hash = SHA256(server_seed)`
3. Server gets `client_seed` (user's Bitcoin address)
4. **User sees**: `server_seed_hash` and `client_seed` (their address)
5. **User does NOT see**: `server_seed` (still secret)

#### **Phase 2: During Bet (Roll Calculation)**
1. User places bet with multiplier (e.g., 2x)
2. System uses:
   - `server_seed` (secret)
   - `client_seed` (user's address)
   - `nonce` (bet counter: 0, 1, 2, ...)
3. Calculates roll using HMAC-SHA512:
   ```
   message = f"{client_seed}:{nonce}"
   hmac_result = HMAC-SHA512(server_seed, message)
   roll = (first_8_hex_chars % 10000) / 100
   ```
4. Result: Roll between 0.00 and 99.99

#### **Phase 3: After Bet (Revelation & Verification)**
1. Server reveals `server_seed` (now public)
2. User can verify:
   - `SHA256(server_seed) == server_seed_hash` ‚úÖ
   - Recalculate roll using revealed seeds ‚úÖ
   - Verify roll matches claimed result ‚úÖ

---

## üé≤ Roll Calculation Formula

```python
# Step 1: Create message
message = f"{client_seed}:{nonce}"
# Example: "tb1qsru9k26ddv9x8y5z4m3n2p1q0w9e8r7t6y5u4i3o2p1a0s9d8f7g6h5j4k3:0"

# Step 2: Calculate HMAC-SHA512
hmac_result = hmac.new(
    server_seed.encode(),  # Key: secret server seed
    message.encode(),       # Message: client_seed:nonce
    hashlib.sha512
).hexdigest()
# Example: "a3f8b2c9d1e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0..."

# Step 3: Extract first 8 hex characters
hex_string = hmac_result[:8]
# Example: "a3f8b2c9"

# Step 4: Convert to integer
result_int = int(hex_string, 16)
# Example: 2756780745

# Step 5: Modulo 10000 and divide by 100
roll = (result_int % 10000) / 100.0
# Example: (2756780745 % 10000) / 100 = 7745 / 100 = 77.45
```

**Result Range**: 0.00 to 99.99

---

## üîí Security Properties

### **Why This System is Provably Fair:**

1. **Server Cannot Cheat Before Bet**:
   - Server commits to `server_seed` by showing `server_seed_hash`
   - Hash is one-way: server cannot change seed without changing hash
   - User can verify hash matches revealed seed later

2. **Server Cannot Cheat After Bet**:
   - Server reveals `server_seed` after bet
   - User can recalculate roll independently
   - If roll doesn't match, user knows server cheated

3. **User Cannot Predict Outcome**:
   - `server_seed` is secret until after bet
   - User cannot calculate roll before placing bet
   - Outcome is truly random

4. **Nonce Prevents Replay**:
   - Each bet increments `nonce` (0, 1, 2, ...)
   - Same seeds + different nonce = different roll
   - Prevents server from reusing same roll

---

## üìä Example Flow

### **Bet #1:**
```
Server Seed:     a3f8b2c9d1e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0
Server Hash:     5e8f3a2b1c9d4e7f6a5b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1
Client Seed:     tb1qsru9k26ddv9x8y5z4m3n2p1q0w9e8r7t6y5u4i3o2p1a0s9d8f7g6h5j4k3
Nonce:           0
Message:         "tb1qsru9k26ddv9x8y5z4m3n2p1q0w9e8r7t6y5u4i3o2p1a0s9d8f7g6h5j4k3:0"
HMAC-SHA512:     a3f8b2c9d1e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0...
First 8 chars:   a3f8b2c9
Decimal:         2756780745
Roll:            (2756780745 % 10000) / 100 = 77.45
```

### **Bet #2 (Same User, Next Bet):**
```
Server Seed:     a3f8b2c9d1e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0 (same)
Server Hash:     5e8f3a2b1c9d4e7f6a5b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1 (same)
Client Seed:     tb1qsru9k26ddv9x8y5z4m3n2p1q0w9e8r7t6y5u4i3o2p1a0s9d8f7g6h5j4k3 (same)
Nonce:           1 (incremented!)
Message:         "tb1qsru9k26ddv9x8y5z4m3n2p1q0w9e8r7t6y5u4i3o2p1a0s9d8f7g6h5j4k3:1"
HMAC-SHA512:     b4e9c3d0e2f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1... (different!)
First 8 chars:   b4e9c3d0
Decimal:         3034564560
Roll:            (3034564560 % 10000) / 100 = 56.00 (different roll!)
```

---

## ‚úÖ Verification Process

After a bet, users can verify:

1. **Hash Verification**:
   ```python
   calculated_hash = SHA256(revealed_server_seed)
   assert calculated_hash == server_seed_hash  # Must match!
   ```

2. **Roll Verification**:
   ```python
   message = f"{client_seed}:{nonce}"
   hmac_result = HMAC-SHA512(server_seed, message)
   roll = (int(hmac_result[:8], 16) % 10000) / 100
   assert abs(roll - claimed_roll) < 0.01  # Must match!
   ```

3. **Overall Verification**:
   - Both checks pass = ‚úÖ **VALID** (Provably Fair)
   - Either check fails = ‚ùå **INVALID** (Possible manipulation)

---

## üéØ Key Takeaways

1. **Server Seed**: Secret random value (revealed after bet)
2. **Server Seed Hash**: Public commitment (shown before bet)
3. **Client Seed**: User's Bitcoin address (known to user)
4. **Nonce**: Bet counter (increments each bet)

**Why 3 Seeds?**
- **Server Seed**: Ensures randomness
- **Server Seed Hash**: Prevents server from cheating
- **Client Seed**: Adds user-controlled randomness
- **Nonce**: Ensures each bet is unique

**Security Guarantee**: 
- Server cannot manipulate results (committed via hash)
- User can independently verify every bet
- System is transparent and auditable

---

## üìù Code References

- **Generation**: `backend/app/services/provably_fair_service.py`
- **Storage**: `backend/app/models/seed.py`
- **Verification**: `backend/app/api/bet_verify_routes.py`
- **Frontend**: `frontend/src/components/FairnessVerifier.js`

---

**This system ensures complete transparency and fairness - every bet can be independently verified by anyone!** üé≤‚ú®
